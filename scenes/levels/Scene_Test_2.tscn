[gd_scene load_steps=13 format=2]

[ext_resource path="res://resources/textures/grass/Grass_Card_Atlas_2.png" type="Texture" id=1]
[ext_resource path="res://resources/materials/Rock.material" type="Material" id=3]
[ext_resource path="res://resources/import3D/terrain/rocks/rocks.obj" type="ArrayMesh" id=4]
[ext_resource path="res://resources/import3D/terrain/test/chunk.obj" type="ArrayMesh" id=5]
[ext_resource path="res://resources/materials/Terrain.material" type="Material" id=6]
[ext_resource path="res://scenes/env/Grass_Gen.tscn" type="PackedScene" id=7]

[sub_resource type="Shader" id=6]
code = "// NOTE: Shader automatically converted from Godot Engine 3.5.1.stable's SpatialMaterial.

shader_type spatial;
render_mode async_visible,cull_back,blend_mix,depth_draw_opaque,ambient_light_disabled;

uniform vec4 albedo : hint_color;
uniform vec4 highlight_albedo : hint_color;
uniform sampler2D texture_atlas : hint_albedo;
uniform vec2 atlas_num_cells;
uniform sampler2D texture_viewport : hint_albedo;
uniform float alpha_scissor_threshold;
uniform float billboard_distance = 10.0;
uniform float specular : hint_range(0,1);
uniform float metallic : hint_range(0,1);
uniform float roughness : hint_range(0,1);
uniform float shadow_adjust : hint_range(0,1) = 0.049;

uniform float wind_speed = 0.2;
uniform float wind_strength = 2.0;
// How big, in world space, is the noise texture
// wind will tile every wind_texture_tile_size
uniform float wind_texture_tile_size = 20.0;
uniform float wind_vertical_strength = 0.3;
uniform vec2 wind_horizontal_direction = vec2(1.0, 0.5);

uniform sampler2D color_ramp : hint_black_albedo;
// we need a tiling noise here!
uniform sampler2D wind_noise : hint_black;
uniform sampler2D v_wind_noise : hint_black;

uniform vec3 character_position;
uniform float character_radius = 3.0;
uniform sampler2D character_distance_falloff_curve : hint_black_albedo;
uniform float character_push_strength = 1.0;
varying float debug_wind;

varying vec2 root_pixel_coords;
varying vec2 atlas_coords;
varying vec3 vert_color;
varying float hfip;
varying vec4 norm;

const float PI = 3.1415926536f;

void vertex() {
	// Get instance data
	vec4 v1 = INSTANCE_CUSTOM;
	vec4 v2 = COLOR;
	hfip = v1.x; //flips the texture horizontally
	
	
	//Cam-Distance based billboard
	//float d = length(WORLD_MATRIX[3].xyz - CAMERA_MATRIX[3].xyz);
	//float b_mix = clamp(d / billboard_distance, 0.0, 1.0);
	float b_mix = v2.a;
	mat4 basis = mat4(
		mix(CAMERA_MATRIX[0], WORLD_MATRIX[0], b_mix),
		CAMERA_MATRIX[1], //mix(CAMERA_MATRIX[1], WORLD_MATRIX[1], b_mix),
		CAMERA_MATRIX[2],
		WORLD_MATRIX[3]
	);
	MODELVIEW_MATRIX = INV_CAMERA_MATRIX * basis;
	
	
	//MODELVIEW_MATRIX = INV_CAMERA_MATRIX * mat4(CAMERA_MATRIX[0],CAMERA_MATRIX[1],CAMERA_MATRIX[2],WORLD_MATRIX[3]);
	//MODELVIEW_MATRIX = MODELVIEW_MATRIX * mat4(vec4(length(WORLD_MATRIX[0].xyz), 0.0, 0.0, 0.0),vec4(0.0, length(WORLD_MATRIX[1].xyz), 0.0, 0.0),vec4(0.0, 0.0, length(WORLD_MATRIX[2].xyz), 0.0),vec4(0.0, 0.0, 0.0, 1.0));
	
	vec4 uv_l = vec4(-1.5, 0.0, 0.0, 1.0);
	vec4 uv_r = vec4(1.5, 0.0, 0.0, 1.0);
	//float detail = 2.0;
	//float mix_amount = floor(UV.x * detail) / detail;
	vec4 local_coords = mix(uv_l, uv_r, UV.x); //local coords of the mix point
	
	
	// transform endpoints to billboard view space
	//v1.xyz = (MODELVIEW_MATRIX * vec4(-0.5, 0.0, 0.0, 1.0)).xyz;
	//v2.xyz = (MODELVIEW_MATRIX * vec4(0.5, 0.0, 0.0, 1.0)).xyz;
	
	v1.xyz = (MODELVIEW_MATRIX * local_coords).xyz;
	
	
	//store normal of terrain (view space)
	v2.a = 0.0;
	norm = INV_CAMERA_MATRIX * v2;
	
	
	// to get back to world space, multiply by camera_matrix (i.e. for indexing into ortho top-down view texture)
	// OR...
	// Just multiply local coordiante vector by mat4(CAMERA_MATRIX[0],CAMERA_MATRIX[1],CAMERA_MATRIX[2],WORLD_MATRIX[3]); (since INV_CAM and CAM matrix cancel out)
	
	
	atlas_coords = vec2(floor(v1.a), (v1.a - floor(v1.a)) * 10.0); //i.e. 5.3 -> vec2(5, 3)
	v1.w = 1.0;
	
	// World space to view space transform.
//	v1 = INV_CAMERA_MATRIX * v1;
//	v2 = INV_CAMERA_MATRIX * v2;
	
	// View space to clip cpace transform
	v1 = PROJECTION_MATRIX * v1;
	//v2 = PROJECTION_MATRIX * v2;
	
	vec2 v1_coords = v1.xy / v1.w / 2.0 + 0.5; //convert to ScreenUV coordinates
	//vec2 v2_coords = v2.xy / v2.w / 2.0 + 0.5;
	//float detail = 10.0;
	//float lerp_amount = 0.5;
	//root_pixel_coords = mix(v1_coords, v2_coords, lerp_amount);
	root_pixel_coords = v1_coords;
	
//	NORMAL = vec3(0.0, -1.0, 0.0);
//	BINORMAL = vec3(0.0, 0.0, 1.0);
	
	// WIND //
	vec3 world_vert = (WORLD_MATRIX * vec4(VERTEX, 1.0)).xyz;
	vec2 normalized_wind_direction = normalize(wind_horizontal_direction);
	vec2 world_uv = world_vert.xz / wind_texture_tile_size + normalized_wind_direction * TIME * wind_speed;
	// we displace only the top part of the mesh
	// note that this means that the mesh needs to have UV in a way that the bottom of UV space
	// is at the top of the mesh
	float displacement_affect = (1.0 - UV.y);
	float wind_noise_intensity = (textureLod(wind_noise, world_uv, 0.0).r - 0.5);

	// We convert the direction of the wind into vertex space from world space
	// if we used it directly in vertex space, rotated blades of grass wouldn't behave properly
	vec2 vert_space_horizontal_dir = 
			(inverse(WORLD_MATRIX) * vec4(wind_horizontal_direction, 0.0, 0.0)).xy;

	vert_space_horizontal_dir = normalize(vert_space_horizontal_dir);

	vec3 bump_wind = vec3(
		wind_noise_intensity * vert_space_horizontal_dir.x,
		1.0 - wind_noise_intensity,
		wind_noise_intensity * vert_space_horizontal_dir.y);

	normalize(bump_wind);

	bump_wind *= vec3(wind_strength, wind_vertical_strength, wind_strength);
	//bump_wind *= vec3(wind_strength, 0.3 - b_mix, wind_strength);

	VERTEX += bump_wind * displacement_affect;

	// At the moment the blades are pushed away in a perfectly circular manner.
	// We could distort the distance to the character based on a noise, to break a bit the
	// circular shape. We could distort the falloff by sampling in a noise based on the xz coordinates.
	// The task is left to the reader

	vec3 dir_to_character = character_position - WORLD_MATRIX[3].xyz;
	// uncomment the following line to have a horizontal only character push
	//dir_to_character.y = 0.0;
	float distance_to_character = length(dir_to_character);
	float falloff = 1.0 - smoothstep(0.0, 1.0, distance_to_character/character_radius);
	// Because we operate in vertex space, we need to convert the direction to the character
	// in vertex space. Otherwise, it wouldn't work for rotated blades of grass.
	// comment the next line to observe how the blades are not all facing away from the character.
	dir_to_character = (inverse(WORLD_MATRIX) * vec4(dir_to_character, 0.0)).xyz;
	dir_to_character = normalize(dir_to_character);

	// sample the curve based on how far we are from the character, in normalized coordinates
	float falloff_curve = texture(character_distance_falloff_curve, vec2(falloff)).x;
	// direction to character is inverted because we want to point away from it
	VERTEX += normalize(-dir_to_character) * falloff_curve * character_push_strength * displacement_affect;
}

void fragment() {
	float x_uv = mix(1.0 - UV.x, UV.x, hfip);
	
	vec2 base_uv = (vec2(x_uv, UV.y) / vec2(4.0, 8.0)) + (atlas_coords / atlas_num_cells);
	vec4 albedo_tex = texture(texture_atlas,base_uv);
	//vec4 albedo_tex = texture(texture_albedo,UV);
	//ALBEDO = albedo.rgb * albedo_tex.rgb;
	//ALBEDO = texture(color_ramp, vec2(1.0 - UV.y, 0)).rgb ;
	ALPHA = albedo.a * albedo_tex.a;
	ALPHA_SCISSOR=alpha_scissor_threshold;
	
	
	//vec3 base_col = texture(texture_viewport, root_pixel_coords.xy).rgb;
	vec3 base_col = textureLod(texture_viewport, root_pixel_coords.xy, 0.0).rgb;
	
//	if (base_col.rgb == vec3(0.0, 0.0, 0.0))
//		discard;
	
	//force sRGB
	//base_col.rgb = mix(pow((base_col.rgb + vec3(0.055)) * (1.0 / (1.0 + 0.055)),vec3(2.4)),base_col.rgb.rgb * (1.0 / 12.92),lessThan(base_col.rgb,vec3(0.04045)));
	
	float highlight_amount = texture(color_ramp, vec2((1.0 - UV.y), 0.0)).r + 1.0;

	ALBEDO = base_col.rgb * highlight_amount;// * albedo.rgb;
	ROUGHNESS = roughness;
	METALLIC = metallic;
	SPECULAR = specular;
	AO_LIGHT_AFFECT = 0.0;
	AO=  0.0;
}


void light() {
	float attn = step(0.5, ATTENUATION.x);

	if (attn == 0.0){
		//DIFFUSE_LIGHT += clamp(dot(norm.xyz, LIGHT), 0.0, 1.0) * ALBEDO;
		DIFFUSE_LIGHT += clamp(dot(norm.xyz, LIGHT), 0.0, 1.0) * ATTENUATION * ALBEDO * (2.0 + shadow_adjust);// * LIGHT_COLOR;
		//DIFFUSE_LIGHT = ATTENUATION.x * ALBEDO * (1.0 + shadow_adjust);// shadow_adjust;// * LIGHT_COLOR;
		//discard;
	}
	else
		DIFFUSE_LIGHT = ALBEDO;



	//vec3 H = normalize(VIEW + LIGHT);
	//float NdotH = max(0, dot(NORMAL, H));
	//float specular = pow(NdotH, specular_power) * specular_strength * ATTENUATION.x;
	//SPECULAR_LIGHT += specular*LIGHT_COLOR;
}"

[sub_resource type="Gradient" id=11]
colors = PoolColorArray( 0, 0, 0, 1, 0.769531, 0.769531, 0.769531, 1 )

[sub_resource type="GradientTexture" id=12]
gradient = SubResource( 11 )

[sub_resource type="OpenSimplexNoise" id=8]

[sub_resource type="NoiseTexture" id=9]
seamless = true
noise = SubResource( 8 )

[sub_resource type="ShaderMaterial" id=13]
resource_local_to_scene = true
shader = SubResource( 6 )
shader_param/albedo = Color( 0.921569, 0.921569, 0.921569, 1 )
shader_param/highlight_albedo = Color( 1, 1, 1, 1 )
shader_param/atlas_num_cells = Vector2( 8, 8 )
shader_param/alpha_scissor_threshold = 0.4
shader_param/billboard_distance = 100.0
shader_param/specular = 0.0
shader_param/metallic = 0.0
shader_param/roughness = 1.0
shader_param/shadow_adjust = 0.049
shader_param/wind_speed = 0.1
shader_param/wind_strength = 0.5
shader_param/wind_texture_tile_size = 200.0
shader_param/wind_vertical_strength = 0.0
shader_param/wind_horizontal_direction = Vector2( 1, 0.5 )
shader_param/character_position = null
shader_param/character_radius = 3.0
shader_param/character_push_strength = 1.0
shader_param/texture_atlas = ExtResource( 1 )
shader_param/color_ramp = SubResource( 12 )
shader_param/wind_noise = SubResource( 9 )

[node name="Test_Level" type="Spatial"]

[node name="Terrain_Test2" type="MeshInstance" parent="."]
layers = 3
material_override = ExtResource( 6 )
mesh = ExtResource( 5 )

[node name="Grass" parent="Terrain_Test2" instance=ExtResource( 7 )]
material_override = SubResource( 13 )

[node name="Rocks" type="MeshInstance" parent="."]
material_override = ExtResource( 3 )
mesh = ExtResource( 4 )
